---
title: "Exploracion_inicial"
author: "Gabriela Centeno y Sofía Zorrilla"
format: html
---

```{r}
# --- Set wd ---
setwd("C:/Users/danie/Desktop/phylogenetic")


# --- Load libraries ---
library(dplyr)
library(readr)
library(data.table)
library(ggplot2)

```

- Subir datos crudos 

El siguiente codigo no sirve en qmd:
# Load tables from gbif 
files_list <- list.files("data/in/gbif_dwc/division_occurrence/", pattern=".csv", full.names=TRUE)


files <- lapply(files_list,fread)

recordsGbif_raw <- do.call(rbind,files)

recordsHerbario_raw <- fread("data/in/herbariomex_dw/occurrences.csv")

gbif_nombres_backbone <- fread("data/temp/backbone_gbif/gbif_nombres_backbone.csv")

herb_nombres_backbone <- fread("data/temp/backbone_gbif/herb_final_backbone.csv")





-   Unir metadatos con la base de datos con los nombres corregidos

```{r}
# --- Generar un id interno para cada tabla
recordsGbif_raw <- recordsGbif_raw %>%
  mutate(id_interno = paste0("GBIF_", row_number()))

recordsHerbario_raw <- recordsHerbario_raw %>%
  mutate(id_interno = paste0("Herb_", row_number()))


# --- Unir columnas del herbario con el herbario corregido 

herb_corr_raw <- cbind(recordsHerbario_raw, herb_nombres_backbone)

# --- Unir columnas de gbif con gbif corregido 

gbif_corr_raw <- cbind(recordsGbif_raw, gbif_nombres_backbone)


```

-   Unir la tabla del herbario y el gbif

```{r}
#Agregar sufijo para que no haya columnas duplicadas
names(herb_corr_raw) <- make.names(names(herb_corr_raw), unique = TRUE)
names(gbif_corr_raw) <- make.names(names(gbif_corr_raw), unique = TRUE)

herb_corr_raw <- herb_corr_raw %>%
  mutate(across(everything(), as.character))

gbif_corr_raw <- gbif_corr_raw %>%
  mutate(across(everything(), as.character))

# Unir las filas de los data frames
gbif_herb_raw <- bind_rows(herb_corr_raw, gbif_corr_raw)


```


-   Seleccionar columnas de interés

```{r}
gbif_herb <- gbif_herb_raw %>%
  select(correctname, decimalLatitude, decimalLongitude, stateProvince, county, municipality,locality, eventDate, year, month, recordedBy, id_interno)
```


-   Contar duplicados

    -   Coordenadas
    
```{r}
#Eliminar registros sin coordenadas 
gbif_herb_coor <- gbif_herb %>%
  filter(!is.na(decimalLatitude) & !is.na(decimalLongitude))

# Identificar las filas duplicadas basadas en las coordenadas
coor_duplicated <- gbif_herb_coor %>%
  filter(duplicated(cbind(decimalLatitude, decimalLongitude)))

```
    
    
    -   Coordenadas, nombre, localidad (puede haber errores de formato en la escritura de localidad)
```{r}
corr_loc_name_dupli <-  gbif_herb_coor%>%
  filter(duplicated(cbind(decimalLatitude, decimalLongitude, correctname, municipality) , fromLast = TRUE))

```
    
    
    -   Replicas del mismo individuo (nombre de los colectores, fecha de colecta y especie)
    
```{r}
colectors_date_species_replica <-  gbif_herb_coor%>%
  filter(duplicated(cbind(recordedBy,eventDate,correctname) , fromLast = TRUE))

```

- Eliminar duplicados 
```{r}
# --- Eliminar por coordenadas, nombre de la especie y localidad

hgbif_no_duplicates_loc_name <- gbif_herb_coor %>%
  distinct(decimalLatitude, decimalLongitude, correctname, municipality, .keep_all = TRUE)

# --- Después eliminar duplicados de recolector, fecha de colecta y especie
hgbif_no_duplicates <- hgbif_no_duplicates_loc_name %>%
  distinct(recordedBy, eventDate, correctname, .keep_all = TRUE)

```

Guardarlo en un csv

No sirve en qmd 

```{r}
write.csv(hgbif_no_duplicates, file = "data/out/hgbif_no_duplicates.csv")
```
- Ver cuantos NA hay 
```{r}
colSums(is.na(hgbif_no_duplicates))

```

    
-   Extraer elevación

```{r}

#Inicia funcion
library(elevatr)
library(data.table)

#Genera el df de elevacion

# Reordena las columnas de la tabla para que decimalLongitude sea la primera y decimalLatitude la segunda

hgbif_no_duplicates_coor <- hgbif_no_duplicates %>%
  mutate(
    decimalLongitude = as.numeric(decimalLongitude),
    decimalLatitude = as.numeric(decimalLatitude)
  ) %>%
  select(decimalLongitude, decimalLatitude)  %>%
  filter(decimalLongitude >= -180 & decimalLongitude <= 180, decimalLatitude >= -90 & decimalLatitude <= 90)


# Convertir a objeto sf

library(sf)

hgbif_no_duplicates_sf <- st_as_sf(hgbif_no_duplicates_coor,coords = c("decimalLongitude", "decimalLatitude"), crs = 4326)


# Obtener elevación para cada punto en tu base de datos
elev_data <- get_elev_point(hgbif_no_duplicates_sf, 
                            src = "aws", # Usa Amazon Web Services como fuente de datos de elevación
                            z = 4)      # Nivel de zoom (determina la precisión)


#guardar en un csv 
write.csv(elev_data, "data/temp/elev_data.csv")

#Generar el df con las coordenadas correctas y todas las columnas para agregar la columna de elevacion a cada registro
hgbif_no_duplicates_coor_completo <- hgbif_no_duplicates %>%
  mutate(
    decimalLongitude = as.numeric(decimalLongitude),
    decimalLatitude = as.numeric(decimalLatitude)
  ) %>%
  select(decimalLongitude, decimalLatitude,everything())  %>%
  filter(decimalLongitude >= -180 & decimalLongitude <= 180, decimalLatitude >= -90 & decimalLatitude <= 90)

#Agregar columna de elevacion
hgbif_no_duplicates_coor_completo$elevacion <- elev_data$elevation

#Ver rango de elevacion que hay 
range(hgbif_no_duplicates_coor_completo$elevacion)


# Filtrar los datos para mantener solo las filas donde la elevación sea mayor o igual a cero
hgbif_no_duplicates_coor_completo <- hgbif_no_duplicates_coor_completo %>%
  filter(elevacion >= 0)

# Verifica el rango después de eliminar las elevaciones negativas
range(hgbif_no_duplicates_coor_completo$elevacion)

```

-   Uno general para ver errores (como puntos que caen el mar)

```{r}

```


-   Tabla de registros por especie
```{r}
species_count <- hgbif_no_duplicates_coor_completo %>%
  count(correctname, name = "total_registros")%>%
  filter(total_registros > 10)



# Now filter the main data frame to only include species with more than 10 records
hgbif_filtered <- hgbif_no_duplicates_coor_completo %>%
  semi_join(species_count, by = "correctname")
```


-   Histograma de fechas
```{r}

# Load lubridate if not already loaded
library(lubridate)

# Extract the year from eventDate
hgbif_filtered <- hgbif_filtered %>%
  mutate(year = year(ymd(eventDate)))

# Crear un histograma por año
ggplot(hgbif_filtered, aes(x = year)) +
  geom_histogram(binwidth = 1, color = "black", fill = "lightblue", alpha = 0.7) +
  labs(title = "Histograma de Fechas de Colecta (Por Año)",
       x = "Año de Colecta",
       y = "Número de Registros") +
  theme_minimal()
```


-   Minímos y maximos de elevación por especie


-   Obtener categoría de especie de la IUCN por especie

```{r}
#| echo: false

# # Instalar los paquetes necesarios si no los tienes
# install.packages(c("httr", "jsonlite"))

# Cargar los paquetes
library(httr)
library(jsonlite)
```

```{r}
# Clave de API de la IUCN (reemplaza "YOUR_IUCN_API_KEY" con tu clave de API)
iucn_api_key <- "8a2sFdrnhH9eBjj1WKE9p46w3GaneBziqRx3"

# Función para obtener la categoría de conservación de una especie
get_iucn_status <- function(species_name) {
  # URL para la consulta
  url <- paste0("https://apiv3.iucnredlist.org/api/v3/species/", URLencode(species_name), "?token=", iucn_api_key)
  
  # Hacer la solicitud a la API
  response <- GET(url)
  
  # Verificar si la solicitud fue exitosa
  if (status_code(response) == 200) {
    data <- fromJSON(content(response, "text"), flatten = TRUE)
    
    # Extraer la categoría de conservación si está disponible
    if (length(data$result) > 0) {
      return(data$result$category)
    } else {
      return(NA)  # Si no hay datos para la especie
    }
  } else {
    warning("Error in request: ", status_code(response))
    return(NA)
  }
}


# Crear una nueva columna con la categoría de la IUCN
species_count <- species_count %>%
  mutate(iucn_category = sapply(correctname, get_iucn_status))


```

